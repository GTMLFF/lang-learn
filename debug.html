<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DB Debug</title>
<style>
body { background: #0a0e1a; color: #f1f5f9; font-family: -apple-system, sans-serif; padding: 20px; font-size: 14px; }
pre { background: #141828; padding: 12px; border-radius: 8px; overflow-x: auto; white-space: pre-wrap; word-break: break-all; margin: 8px 0; }
button { background: #6366f1; color: white; border: none; padding: 10px 20px; border-radius: 8px; margin: 4px; font-size: 14px; }
h3 { margin-top: 20px; color: #6366f1; }
.ok { color: #10b981; }
.err { color: #ef4444; }
</style>
</head>
<body>
<h2>ğŸ” EnglishLearn DB è¯Šæ–­</h2>
<div id="output"></div>
<button onclick="runDiag()">è¿è¡Œè¯Šæ–­</button>
<button onclick="testInsert()">æµ‹è¯•å†™å…¥å¯¹è¯</button>

<script src="https://unpkg.com/dexie@3/dist/dexie.min.js"></script>
<script>
const log = (msg, cls='') => {
    document.getElementById('output').innerHTML += `<pre class="${cls}">${msg}</pre>`;
};

async function runDiag() {
    document.getElementById('output').innerHTML = '';
    try {
        const db = new Dexie('EnglishLearnDB');
        
        // Check if DB exists
        const exists = await Dexie.exists('EnglishLearnDB');
        log(`æ•°æ®åº“æ˜¯å¦å­˜åœ¨: ${exists}`, exists ? 'ok' : 'err');
        
        if (!exists) {
            log('âŒ æ•°æ®åº“ä¸å­˜åœ¨ï¼è¯·å…ˆåœ¨ä¸»é¡µé¢å¯¼å…¥æ•°æ®ã€‚', 'err');
            return;
        }

        // Open with same schema
        db.version(1).stores({
            sentences: '++id, createdAt',
            dialogueSessions: '++id, createdAt',
            dialogueLines: '++id, sessionId, speaker, order',
            vocabulary: '++id, createdAt',
            cardProgress: '++id, [type+itemId], type, itemId, nextReview'
        });
        db.version(2).stores({
            sentences: '++id, createdAt, topic',
            dialogueSessions: '++id, createdAt, topic',
            dialogueLines: '++id, sessionId, speaker, order',
            vocabulary: '++id, createdAt, topic',
            cardProgress: '++id, [type+itemId], type, itemId, nextReview'
        });

        await db.open();
        log('âœ… æ•°æ®åº“æ‰“å¼€æˆåŠŸï¼Œç‰ˆæœ¬: ' + db.verno, 'ok');

        // Count all tables
        const tables = ['sentences', 'dialogueSessions', 'dialogueLines', 'vocabulary', 'cardProgress'];
        for (const t of tables) {
            const count = await db.table(t).count();
            log(`ğŸ“Š ${t}: ${count} æ¡è®°å½•`, count > 0 ? 'ok' : '');
        }

        // Show dialogue sessions detail
        const sessions = await db.dialogueSessions.toArray();
        log('\n=== å¯¹è¯ä¼šè¯è¯¦æƒ… ===');
        if (sessions.length === 0) {
            log('âŒ dialogueSessions è¡¨ä¸ºç©ºï¼æ•°æ®æ²¡æœ‰æˆåŠŸå†™å…¥ã€‚', 'err');
        } else {
            sessions.forEach(s => {
                log(`  ID:${s.id} | ä¸»é¢˜:"${s.topic}" | æ ‡é¢˜:"${s.title}" | è¡Œæ•°:${s.lineCount} | åˆ›å»º:${s.createdAt}`, 'ok');
            });
        }

        // Show dialogue lines
        const lines = await db.dialogueLines.toArray();
        log(`\n=== å¯¹è¯è¡Œè¯¦æƒ… (å‰5æ¡) ===`);
        lines.slice(0, 5).forEach(l => {
            log(`  SessionID:${l.sessionId} | ${l.speaker}: ${l.content.slice(0, 50)}...`);
        });

        // Test orderBy
        log('\n=== æµ‹è¯• orderBy createdAt ===');
        try {
            const ordered = await db.dialogueSessions.orderBy('createdAt').reverse().toArray();
            log(`âœ… orderBy æˆåŠŸï¼Œè¿”å› ${ordered.length} æ¡`, 'ok');
        } catch(e) {
            log(`âŒ orderBy å¤±è´¥: ${e.message}`, 'err');
        }

        db.close();
    } catch(e) {
        log(`âŒ è¯Šæ–­å‡ºé”™: ${e.message}\n${e.stack}`, 'err');
    }
}

async function testInsert() {
    document.getElementById('output').innerHTML = '';
    try {
        const db = new Dexie('EnglishLearnDB');
        db.version(1).stores({
            sentences: '++id, createdAt',
            dialogueSessions: '++id, createdAt',
            dialogueLines: '++id, sessionId, speaker, order',
            vocabulary: '++id, createdAt',
            cardProgress: '++id, [type+itemId], type, itemId, nextReview'
        });
        db.version(2).stores({
            sentences: '++id, createdAt, topic',
            dialogueSessions: '++id, createdAt, topic',
            dialogueLines: '++id, sessionId, speaker, order',
            vocabulary: '++id, createdAt, topic',
            cardProgress: '++id, [type+itemId], type, itemId, nextReview'
        });
        await db.open();

        const now = new Date().toISOString();
        const sessionId = await db.dialogueSessions.add({
            title: 'Debug Test Session',
            lineCount: 2,
            topic: 'Debug Topic',
            createdAt: now
        });
        log(`âœ… å†™å…¥ä¼šè¯æˆåŠŸ, ID: ${sessionId}`, 'ok');

        await db.dialogueLines.bulkAdd([
            { sessionId, speaker: 'User', content: 'Hello, how are you?', chinese: 'ä½ å¥½ï¼Œä½ æ€ä¹ˆæ ·ï¼Ÿ', order: 0, createdAt: now },
            { sessionId, speaker: 'Coach', content: 'I am fine, thanks!', chinese: 'æˆ‘å¾ˆå¥½ï¼Œè°¢è°¢ï¼', order: 1, createdAt: now }
        ]);
        log(`âœ… å†™å…¥å¯¹è¯è¡ŒæˆåŠŸ`, 'ok');

        // Verify read back
        const sessions = await db.dialogueSessions.orderBy('createdAt').reverse().toArray();
        log(`âœ… è¯»å› ${sessions.length} ä¸ªä¼šè¯`, 'ok');
        sessions.forEach(s => {
            log(`  ID:${s.id} | "${s.topic}" | "${s.title}" | ${s.lineCount}è¡Œ`);
        });

        log('\nç°åœ¨è¯·å›åˆ°ä¸»é¡µé¢çš„å¯¹è¯é¡µé¢æŸ¥çœ‹æ˜¯å¦æ˜¾ç¤ºã€‚', 'ok');
        db.close();
    } catch(e) {
        log(`âŒ æµ‹è¯•å†™å…¥å‡ºé”™: ${e.message}\n${e.stack}`, 'err');
    }
}
</script>
</body>
</html>
